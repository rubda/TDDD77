\section{Teori}

\subsection{Allmän design av biblioteket}
Alla operationer på matriser och vektorer bygger i grunden på matris structen som är definierad i matLib.h.
\lstinputlisting[language=C]{martin-tex/matrix_struct.c}
När en matris skapas så används följande funktion:
\lstinputlisting[language=C]{martin-tex/create_matrix.c}
Som skapar en $row \ x \ column$ stor matris. \\ \\
För att sätt in ett värde i matris används följande funktion:
\lstinputlisting[language=C]{martin-tex/insert_value.c}
Matriserna lagras row major så datan ligger lagrad enligt figur 1. 
\begin{figure}[h]
\center
\scalebox{0.8}{\input{martin-tex/matrix_dia}}
\caption{Ordning som data i matrisen lagras på}
\end{figure}


\subsection{Tidskomplexitet på nuvarande implementationer operationer}
Alla tidskomplexiteter beräknas på nxn matriser.
Addition: $\mathcal{O}(n^2)$\\
Subtraktion: $\mathcal{O}(n^2)$\\
Multiplikation: $\mathcal{O}(n^3)$\\
Invers (crout och sedan lösa n ekvationssystem): $\mathcal{O}(n^3)$\\ 

\subsection{Algoritmiska förbättringar}
Multiplikation:\\
Istället för den naive algoritmen kan strassen algoritmen implementeras vilket reducerar tidskomplexiteten från $\mathcal{O}(n^3)$ till $\mathcal{O}(n^{2.807})$ \cite{Strassen1969}. \\
Inverse:\\
Istället för crout så kan inversen beräknas med strassen algoritmen och på så sätt så sänks tidskomplexiteten från $\mathcal{O}(n^3)$ till $\mathcal{O}(n^{2.807})$. Denna algoritm har dock en stor nackdel som beskrivs i sektion \ref{sec:inverse_nackdelar}.

\subsection{Strukturella förbättringar}
När ett linjärt ekvationssystem på formen $Ax=b $ löses så bryts A ned till två matriser L och U där L är en undre triangulär matris och U är en övre triangulär matris. I matris structen skulle dessa matriser kunna sparas tillsammans med en boolean som säger om matrisen har modifierats så skulle man kunna undvika att beräkna U och L flera gånger för samma matris. Samma sätt skulle kunna användas för inversen till matriser. 

\subsection{Nackdelar med Strassen algoritmen för beräkning av inverser}
Matrisen man ska invertera delas upp i fyra submatriser på följande sätt:
$$A=\begin{bmatrix}
A_{11} & A_{12} \\
A_{21}& A_{22}
 \end{bmatrix}
 $$
 Där inversen till $A$ beräknas på följande sätt\cite{Petkovic2013}:
 \begin{align}
  R_1 & =A_{11}^{-1} \\
  R_2 & =A_{21}R_1 \\
  R_3 & =R_1A_{12} \\
  R_4 & =A_{21}R_3 \\
  R_5 & =R_4 -A_{22} \\
  R_6 & =R_1^{-1} \\
  X_{12} & =R_3R_6 \\
  X_{21} & =R_6R_2 \\
  R_7 & =R_3X_{21} \\
  X_{11} & =R_1 -R7 \\
  X_{22} & =-R_6 \\
 A^{-1} & =\begin{bmatrix}
X_{11} & X_{12} \\
X_{21}& X_{22}
 \end{bmatrix}
 \end{align}
 Här så kan $A_{11}^{-1}$ och $R_1^{-1}$ beräknas rekursivt med samma algoritm. Det stora problemet med denna algoritm är att samtliga submatriser måste vara inverterbara. Det vill säga följande måste vara uppfyllt:
 \begin{align}
   A_{11}A_{11}^{-1}= & I_n \\
   A_{12}A_{12}^{-1}= & I_n \\
   A_{21}A_{21}^{-1}= & I_n \\
   A_{22}A_{22}^{-1}= & I_n \\
 \end{align}
 Ta till exempel identitetsmatrisen $I_n$ som är invertbar då den är sin egna invers. Om denna delas upp i submatriser enligt strassen algoritmen så får man följande:
 
 $$ I_n =
 \begin{bmatrix}
   1 & 0 & 0 & \cdots & 0 \\
  0 & 1 & 0 & \cdots & 0 \\
  0 & 0 & 1 & \cdots & 0 \\
  \vdots  & \vdots  & \vdots & \ddots  \\
  0 & 0 & 0 & \cdots & 1
 \end{bmatrix}
 $$
 $$I_nI_n=I_n$$
 Anta att $n$ är ett jämnt tal så $I_n$ kan delas upp i fyra lika stora submatriser.
 
  $$ I_{11}=I_{22} =
 \begin{bmatrix}
   1 & 0 & 0 & \cdots & 0 \\
  0 & 1 & 0 & \cdots & 0 \\
  0 & 0 & 1 & \cdots & 0 \\
  \vdots  & \vdots  & \vdots & \ddots  \\
  0 & 0 & 0 & \cdots & 1
 \end{bmatrix}
 I_{12}=I_{21}=
  \begin{bmatrix}
   0 & 0 & 0 & \cdots & 0 \\
  0 & 0 & 0 & \cdots & 0 \\
  0 & 0 & 0 & \cdots & 0 \\
  \vdots  & \vdots  & \vdots & \ddots  \\
  0 & 0 & 0 & \cdots & 0
 \end{bmatrix}
 $$
 Då $I_{12}$ och $I_{21}$ är nollmatriser och inte inverterbara så kan strassen algoritmen ej tillämpas på alla matriser även om de är inverterbara. 
 

 
\label{sec:inverse_nackdelar}